pro crater2, PLD = pld
  ;closewin ; this line just closes all open IDL graphics windows currently open.

  ; 1) We have a square portion of planetary surface 500km^2, subject to impacts
  ;    at average rate of once per 1000yrs.

  impact_site = fltarr(500,500)+1 ;500x500km area of planetary surface with thickness of 1km.
  ; We will be counting which craters are detectable after each impact (basically a function of time)
  ; and at each 1000 year time step we will plot how many are visible at that time. The number of detected
  ; craters as a function of time will be stored as an array in the 'crater history' array.
  crater_history =[]

  ; A single saturation plot is generated, which is continually updated with each impact (expensive in computing
  ; time, but allows you to see the impact of each crater, which is useful when a power law distrobution for
  ; asteroid sizes is used and an uncommonly large asteroid impacts the surface). We could very well reserve the
  ; plotting for once every 1 Myrs, but seeing it in "real time" is much more fun!
  plt = window(dimensions = [500,500])
  ; A single image window is also used to see when and where each impact occurs. This also costs computing time,
  ; but we already covered the motivation behind that.
  im1 = window(dimensions = [500,500])
  im1.window.setcurrent


  ; 2) Time is incremented in 1000 yr steps, with one impact per time step, starting at t equals zero.
  t = 0

  ; In order to track each impact location and test for its detectability, we will save some parameters for
  ; each impact to an array, where each array element is a dictionary of an impact's parameters (explained below).
  impact_catalog = []



  while t lt 1e4 do begin; hey, we gotta stop somewhere :/
    ; The 'xlist' and 'ylist' hold the coordinates of the impact site within the bounds of each crater.
    xlist = []
    ylist = []
    ; Here is where we can vary the sizes of the impactors. If the keyword 'pld' (power law distrobution) is set,
    ; then we have a powerlaw probability distrobution of impactor size, given by the value provided of this keyword.
    if not keyword_set(pld) then R_asteroid = 5 else randomp, R_asteroid ,-pld,1,range_x = [1,30]

    ; THE crater IS GENERATED - Oh shit, the sky is falling!
    ; As per class discussion, the crater radius generated by the impactor is 10 times the impactor radius.
    R_crater = 10*R_asteroid; in kilometers
    ; NOTE: At this point we reiterate that the crater depth is assumed to be a constant 0.5 km. This will
    ; be the same for all impacts.

    ; THE LOCATION OF THE IMPACT IS GENERATED - Oh no! That metor is headed straight for that truck! Dont worry, its a Toyota Tundra.  ]B)
    ; The impact locations are generated randomly for the x and y coordinates on the surface. The '500' ensures we are returned a
    ; number between 0 and 500 for the x and y coordinates, since the random function returns only floating values up to .9999
    impact_locx = round(randomu(!null)*500) & impact_locy = round(randomu(!null)*500)


    ; THE DEPTH OF THE crater IS APPLIED TO THE SURFACE
    ; For every coordinate on the planetary impact surface, we test to see if the coordinates fall within the crater location.
    for x =0,499 do begin; in km
      for y =0,499 do begin; km

        ; We can simply use the circle plotting formula from high school geometry class to determine which coordinates
        ; are effected by the impact. All locations within the radius of the crater are set to be crater depth of 0.5 km.
        if sqrt((x-impact_locx)^2+(y-impact_locy)^2) lt R_crater then begin
          ; reduce the surface by amount of crater within crater diameter (carve out huge mass)
          impact_site[x,y]= 0.5
        endif

        ; Critical to the detection effort, we create an inner rim of the crater that is .25 km below the planetary surface.
        ; In other words, the thickness of our planetary impact "slab" is reduced to .75 km.
        ; The extent of the crater is the last 90% of the crater radius.
        if sqrt((x-impact_locx)^2+(y-impact_locy)^2) ge R_crater*.9 and $
          sqrt((x-impact_locx)^2+(y-impact_locy)^2) le R_crater then begin
          impact_site[x,y]= .75

          ; now that we have coordinates for the impact, we save them to the 'xlist' and 'ylist'.
          xlist = [xlist, x]
          ylist = [ylist, y]
        endif
      endfor
    endfor



    ; THE IMPACT CATALOG IS UPDATED WITH crater METADATA
    ; The impact will be cataloged! Each entry will be a dictionary variable with the x,y coords within the crater, impact location 'r', and 
    impact_catalog = [impact_catalog, dictionary('x',xlist, 'y',ylist, 'center',[impact_locx,impact_locy],'r',R_crater) ]

    ; THE crater IS IDENTIFIED BY THE RIM
    ; How many craters can we see now, after this latest impact?
    observed_craters = 0
    ; Test the visibility for each crater still in the catalog of (visible)craters, with a counter...named 'counter'.
    counter = 0
    
    foreach crater_rim,impact_catalog do begin
      ; Measure the height where each crater's rim should be, according to the location of the rim. 
      crater_rim_height = impact_site[crater_rim.x,crater_rim.y]
      ; To detect a crater, at least 30% of the rim must be at a value of 0.75km (above the 'mantle'?) 
      crater_rim_observability = n_elements(where(crater_rim_height eq 0.7500))*1.0/n_elements(crater_rim_height)*100
      ; if the crater rim is 30% detectable, then we add one to the count of detected craters, else we remove it 
      ; from the catalog of crators since we dont need to search for visibiliy of this crater anymore. This corresponds
      ; to a crater being "erased" by another impact. 
      if crater_rim_observability gt 30 then observed_craters +=1
      if crater_rim_observability le 30 then begin
        print, "imapact # ", strcompress(counter), " has observability of ", strcompress(crater_rim_observability), " centered at ", strcompress(crater_rim.R)
        print, "Removed a crater from observed counts."
        ;print, "Stddev(crater_rim_height) = ", Stddev(crater_rim_height)
        ;stop
        remove,counter, impact_catalog
      endif
      counter+=1; move to the next crator in the catalog
    endforeach

    print, "# Observed craters:", strcompress(observed_craters)
    crater_history = [crater_history, observed_craters]
    print, "# Impacts to date:", strcompress(t+1)

    t+=1; move to the next 1000 yrs when another impact happens

    if t mod 100 eq 0 then begin 
      im1.window.setcurrent
      img = image(impact_site, /current, margin = 0)
      plt.window.setcurrent
      pl = plot(indgen(t+1, start= 0),crater_history, /overplot, xtitle ='Time (1000 yrs)', ytitle = "Visable Craters")
      stop
    endif
    
  endwhile


end;
